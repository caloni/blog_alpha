<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - 2 Coelhos</title>
  <meta name="author" content="" />
  <meta name="generator" content="Hugo 0.110.0">
  <meta property="og:title" content="2 Coelhos"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/todo-put-original-title-slug/"/>
  <meta property="og:image"
        content="/img/author.jpg"/>
  <meta property="og:description"
        content="Uma montagem impec·vel consegue dar o tom da narrativa do complexo 2 Coelhos. AlÈm de complexo, existem pequenos detalhes da trama que forÁam um pouco a realidade (como a uni„o entre o protagonista e..."/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>
  <link rel="stylesheet" type="text/css" href="/css/jquery-ui.css"/>
  <link rel="stylesheet" type="text/css" href="/css/board-min.css"/>
  <script src="/js/jquery-1.10.2.js"></script>
  <script src="/js/jquery-ui.js"></script>
  <script src="/js/pgnyui.js"></script>
  <script src="/js/pgnviewer.js"></script>
  <script src="/js/list.js"></script>
  <link rel="icon" href="/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
  <nav class="navbar has-shadow is-white"
        role="navigation" aria-label="main navigation">
  <div class="container">
  <div class="navbar-brand">
  <pre><span style="font-size: 3px; margin: 0; display: block;">
&amp;*/. .*%@@@@@@@@@@@@&amp;/    , &amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@#,*@@@@%,*&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@./@.(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@**#./((,*, *./((*,#,&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@.#@@%&amp;@@* (@@%&amp;@@/#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@,#@@&amp;&amp;@@, (@@&amp;&amp;@@*#@@@@@@@@@@@@@#/,,.         ..,/#&amp;@@@@@@@@@@@@@@@@@@@@@@@
@@@@@&amp;, .//      .//  .%@@@@@@&amp;#.  .,****.,*************,.  .(&amp;@@@@@@@@@@@@@@@@@
@@@*                     ,@/  .**,,,*********,   ,***,   ****    *@@@@@@@@@@@@@@
@#                         ,***      .******       ,***,*****,      *&amp;@@@@@@@@@@
&amp;                           ,**      .******.     .******************  (@@@@@@@@
                             ****..,*************************,    ,***   (@@@@@@
@@@@#,,,,,,,,,,,,,,,,,,,,*********,   ,**************,  .***,      .**. .  %@@@@
@@@@%                   .***,.,****,.,***,     ,****      ***.     ,******, /@@@
@@@@@&amp;.                ,**       *******,       *****,  .******************, *@@
@@@@@@@&amp;,            ,****      .********,.   .*************,  ,*****,    ,** /@
@@@@@@@@@@@@&amp;/ .****,    ************.   ****************************      **. #
@@@@@@@@@@@@@, *****,    ,***********    .******,   ,****.   .*****,***,,***** ,
@@@@@@@@@@@@&amp;..**************,  ,***********************       ,*,    ********..
@@@@@@@@@@@@&amp; ,**.    ,******.  .*******.    .**********,     .**********. .**, 
@@@@@@@@@@@@% ,*       ,***************.      .*****************************,   
@@@@@@@@@@@@@&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@,(&amp;&amp;&amp;&amp;@,(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;#*@&amp;&amp;&amp;@*#&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;
@@@@@@@@@@@@@@@@@@@@@@@@@@@@(.#@@@@(.#@@@@@@@@@@@@@@@@@@@@@#**@@@@(.#@@@@@@@@@@@
  </span></pre>
  &nbsp;
  <a class="navbar-item" title="Go to Home" href="/">
    <div class="is-6">Blogue do Caloni</div>
  </a>
  </div>
  </div>
  </nav>
  <div class="container">
  <p class="title">
  <a class="external" href="https://www.caloni.com.br/todo-put-external-link-here">
  Todo Put Post Title Here
  </a>
  </p>
  <div class="content">
<p>Como pudemos ver no [artigo anterior] o processo para carregar uma DLL pelo WinDbg √© muito extenso, enfadonho e sujeito a erros. Al√©m de desatualizado (com comandos de assembly 32 bits). Por esse motivo, e para tornar as coisas mais divertidas, resolvi transformar tudo aquilo em um simples script que pode ser executado digitando apenas uma linha. Tenha em mente que este artigo continua desatualizado usando assembly 32 bits e hoje √© uma mera curiosidade para aprendizado do passado. E se trata do meu primeiro script grande para o WinDbg, por isso, pe√ßo que tenham d√≥ de mim =).</p>
<p>Um script no WinDbg nada mais √© que uma execu√ß√£o em batch: um arquivo texto cheio de comandos que poder√≠amos digitar manualmente, mas que preferimos guardar para poupar nossos dedos. Existem quatro maneiras diferentes de chamar um script no WinDbg, todas muito parecidas, variando apenas se s√£o permitidos espa√ßos antes do nome do arquivo e se os comandos s√£o condensados, isto √©, as quebras de linhas substitu√≠das por ponto-e-v√≠rgula para executar tudo em uma linha s√≥.</p>
<p>	</p>
<p> - $<nome-do-arquivo - n√£o permite espa√ßos e condensa comandos.</p>
<p> - $><nome-do-arquivo - n√£o permite espa√ßos e n√£o condensa comandos.</p>
<p> - $$<nome-do-arquivo - permite espa√ßos e condensa comandos.</p>
<p> - $$><nome-do-arquivo - permite espa√ßos e n√£o condensa comandos.</p>
<p> - $$>a<nome-do-arquivo - igual ao anterior, e ainda permite passar argumentos.</p>
<p>A ajuda do WinDbg descreve as diferen√ßas dos comandos acima de forma adversa, afirmando que os comandos '<'  n√£o condensam as linhas e os '><' o fazem, quando na realidade √© o contr√°rio. N√£o se deixe enganar por esse detalhe. No caso do script desse artigo, utilizaremos a √∫ltima forma, pois precisamos de um argumento para funcionar: o nome da DLL. Caso voc√™ n√£o digite esse argumento, a ajuda do script ser√° impressa:</p>
<p>    How to use:</p>
<p>    $$>a<path\LoadLibrary.txt mydll.dll</p>
<p>    $$>a<path\LoadLibrary.txt c:\\path\\mydll.dll</p>
<p>    $$>a<path\LoadLibrary.txt "c:\\path with space\\mydll.dll"</p>
<p>N√£o h√° qualquer dificuldade. Tudo que voc√™ tem que fazer √© baixar o [script que carrega DLLs] e salv√°-lo em um lugar de sua prefer√™ncia. Depois √© s√≥ digitar o comando que carrega scripts, o path de nosso script e o nome da DLL a ser carregada em uma das tr√™s formas exibidas. Eu costumo criar uma pasta chamada "scripts" dentro do diret√≥rio de instala√ß√£o do Debugging Tools, o que quer dizer que posso simplesmente chamar todos meus scripts (ou seja, 1) dessa maneira:</p>
<p>    </p>
<p>    $$>a<scripts\LoadLibrary.txt mydll.dll</p>
<p>Abaixo um pequeno teste que fiz carregando a DLL do Direct Draw (ddraw.dll) na nossa v√≠tima de plant√£o:</p>
<p>    windbg notepad.exe</p>
<p>    Microsoft (R) Windows Debugger Version 6.8.0004.0 X86</p>
<p>    Copyright (c) Microsoft Corporation. All rights reserved.</p>
<p>    CommandLine: notepad.exe</p>
<p>    Symbol search path is: SRV*C:\Symbols*http://msdl.microsoft.com/downloads/symbols</p>
<p>    Executable search path is:</p>
<p>    ModLoad: 01000000 01014000   notepad.exe</p>
<p>    ModLoad: 7c900000 7c9b0000   ntdll.dll</p>
<p>    ModLoad: 7c800000 7c8f5000   C:\WINDOWS\system32\kernel32.dll</p>
<p>    ...</p>
<p>    ModLoad: 73000000 73026000   C:\WINDOWS\system32\WINSPOOL.DRV</p>
<p>    (8e8.214): Break instruction exception - code 80000003 (first chance)</p>
<p>    eax=001a1eb4 ebx=7ffdf000 ecx=00000000 edx=00000001 esi=001a1f48 edi=001a1eb4</p>
<p>    eip=7c901230 esp=0007fb20 ebp=0007fc94 iopl=0         nv up ei pl nz na po nc</p>
<p>    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202</p>
<p>    ntdll!DbgBreakPoint:</p>
<p>    7c901230 cc              int     3</p>
<p>    0:000> $$>addraw.dll</p>
<p>    ModLoad: 73bc0000 73bc6000   C:\WINDOWS\system32\DCIMAN32.dll</p>
<p>    ModLoad: 76390000 763ad000   C:\WINDOWS\system32\IMM32.DLL</p>
<p>    ModLoad: 629c0000 629c9000   C:\WINDOWS\system32\LPK.DLL</p>
<p>    ModLoad: 74d90000 74dfb000   C:\WINDOWS\system32\USP10.dll</p>
<p>    Freed 0 bytes starting at 00280000</p>
<p>    eax=001a1eb4 ebx=7ffdf000 ecx=00000000 edx=00000001 esi=001a1f48 edi=001a1eb4</p>
<p>    eip=7c901230 esp=0007fb20 ebp=0007fc94 iopl=0         nv up ei pl nz na po nc</p>
<p>    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202</p>
<p>    ntdll!DbgBreakPoint:</p>
<p>    7c901230 cc              int     3</p>
<p>Simples e indolor. Vamos agora dar uma olhada no script completo e dissecar as linhas pausadamente. Dessa forma entenderemos como a fun√ß√£o inteira funciona e como usar os comandos isoladamente para criar novos scripts.</p>
<p>    $$</p>
<p>    $$ @brief Loads a module inside the debuggee process.</p>
<p>    $$ @author Wanderley Caloni <wanderley@caloni.com.br></p>
<p>    $$ @date 2007-11</p>
<p>    $$</p>
<p>    .if( ${/d:$arg1} )</p>
<p>    {</p>
<p>        r $t2 = @$ip</p>
<p>        .foreach /pS 5 ( addr { .dvalloc 0x1000 } ) { r$t0 = addr }</p>
<p>        r $t1 = @$t0 + 0x100</p>
<p>        eza @$t0 "${$arg1}"</p>
<p>        .echo Trying to load the following module:</p>
<p>        da @$t0</p>
<p>        $$ push $ip</p>
<p>        eb @$t1 0x68</p>
<p>        ed @$t1 + 0x01 @$t2</p>
<p>        $$ pushfd</p>
<p>        eb @$t1 + 0x05 0x9c</p>
<p>        $$ pushad</p>
<p>        eb @$t1 + 0x06 0x60</p>
<p>        $$ push $t0</p>
<p>        eb @$t1 + 0x07 0x68</p>
<p>        ed @$t1 + 0x08 @$t0</p>
<p>        $$ call LoadLibrary</p>
<p>        eb @$t1 + 0x0c 0xe8</p>
<p>        ed @$t1 + 0x0d ( kernel32!LoadLibraryA - @$t1 - 0x11 )</p>
<p>        $$ popad</p>
<p>        eb @$t1 + 0x11 0x61</p>
<p>        $$ popfd</p>
<p>        eb @$t1 + 0x12 0x9d</p>
<p>        $$ ret</p>
<p>        eb @$t1 + 0x13 0xc3</p>
<p>        r $ip = @$t1</p>
<p>        bp /1 @$t2 ".dvfree @$t0 0"</p>
<p>        g</p>
<p>    }</p>
<p>    .else</p>
<p>    {</p>
<p>       .echo How to use:</p>
<p>       .echo $$>a<path\LoadLibrary.txt mydll.dll</p>
<p>       .echo $$>a<path\LoadLibrary.txt c:\\path\\mydll.dll</p>
<p>       .echo $$>a<path\LoadLibrary.txt "c:\\path with space\\mydll.dll"</p>
<p>    }</p>
<p>Como podemos ver, ele √© um pouco grandinho. Por isso mesmo que ele √© um script, j√° que n√£o precisamos, sempre que formos usar este comando, ficar olhando para o fonte. Por falar em olhar, uma primeira olhada revela a seguinte estrutura:</p>
<p>    </p>
<p>    .if( ${/d:$arg1} )</p>
<p>    {</p>
<p>       ...</p>
<p>    }</p>
<p>    .else</p>
<p>    {</p>
<p>       ...</p>
<p>    }</p>
<p>Qualquer semelhan√ßa com as instru√ß√µes em C n√£o √© mera coincid√™ncia. Essa estrutura de fato verifica se o resultado dentro do .if √© verdadeiro. No caso o script verifica se o primeiro par√¢metro foi passado, j√° que os argumentos s√£o acess√≠veis atrav√©s dos alias (apelidos) $arg1 - $argn. Essa maneira de usar os argumentos passados no WinDbg ainda n√£o foi documentada, mas encontrei essa dica em [um artigo do Roberto Farah], um grande escritor de scripts para o WinDbg.</p>
<p>Da mesma forma, o que n√£o deve ser nenhuma surpresa, o WinDbg suporta coment√°rios. Todas as linhas que cont√™m '$$' isoladamente s√£o coment√°rios, e seu conte√∫do da direita √© ignorado, salvo se for encontrado um ponto-e-v√≠rgula. A primeira coisa que fazemos para carregar a DLL √© salvar o estado do registrador IP, que indica onde est√° a pr√≥xima instru√ß√£o:</p>
<p>    </p>
<p>        r $t2 = @$ip</p>
<p>Feito isso, usamos um comando n√£o t√£o comum, mas que pode ser muito √∫til nos casos em que precisamos capturar algum dado da sa√≠da de um comando do WinDbg e us√°-lo em outro comando. A estrutura do .foreach deixa o usu√°rio especificar dois grupos de comandos: o primeiro grupo ir√° gerar uma sa√≠da que pode ser aproveitada no segundo grupo.</p>
<p>    </p>
<p>    .foreach /pS 5 $$pula; ( addr $$alias; { .dvalloc 0x1000 $$sa√≠da; } ) { r$t0 = addr }</p>
<p>A op√ß√£o "/pS 5" diz ao comando para pular 5 posi√ß√µes antes de capturar o token que ser√° usado no pr√≥ximo comando. Os tokens s√£o divididos por espa√ßo. Sendo a sa√≠da de ".dvalloc 0x1000" o "Allocated 1000 bytes starting at 00280000". Pulando 5 posi√ß√µes iremos capturar o endere√ßo onde a mem√≥ria foi alocada. E √© isso mesmo que queremos!</p>
<p>    1         2    3     4        5  6</p>
<p>    Allocated 1000 bytes starting at 00280000</p>
<p>O sin√¥nimo do endere√ßo (alias) se torna "addr", apelido que usamos ao executar o segundo comando, que armazena o endere√ßo no registrador tempor√°rio $t0:</p>
<p>    </p>
<p>    r$t0 = addr</p>
<p>Ap√≥s alocada a mem√≥ria, gravamos o par√¢metro de LoadLibrary, o path da DLL a ser carregada, em seu in√≠cio.</p>
<p>    </p>
<p>    eza @$t0 "${$arg1}"</p>
<p>O c√≥digo assembly que ir√° chamar fica um ponto √† frente, mas na mesma mem√≥ria alocada.</p>
<p>    </p>
<p>    r $t1 = @$t0 + 0x100</p>
<p>Conforme as t√©cnicas v√£o cada vez ficando mais "n√£o-usuais", mais dif√≠cil fica achar um nome para a coisa. Essa t√©cnica de escrever o assembly de um c√≥digo atrav√©s de escritas em hexadecimal dentro de um script do WinDbg eu chamei de "script assembly". Se tiver um nome melhor, n√£o se acanhe em us√°-lo. E me deixe saber =).</p>
<p>    $$ push $ip</p>
<p>    eb @$t1 0x68</p>
<p>    ed @$t1 + 0x01 @$t2</p>
<p>    $$ pushfd</p>
<p>    eb @$t1 + 0x05 0x9c</p>
<p>    $$ pushad</p>
<p>    eb @$t1 + 0x06 0x60</p>
<p>    $$ push $t0</p>
<p>    eb @$t1 + 0x07 0x68</p>
<p>    ed @$t1 + 0x08 @$t0</p>
<p>    $$ call LoadLibrary</p>
<p>    eb @$t1 + 0x0c 0xe8</p>
<p>    ed @$t1 + 0x0d ( kernel32!LoadLibraryA - @$t1 - 0x11 )</p>
<p>    $$ popad</p>
<p>    eb @$t1 + 0x11 0x61</p>
<p>    $$ popfd</p>
<p>    eb @$t1 + 0x12 0x9d</p>
<p>    $$ ret</p>
<p>    eb @$t1 + 0x13 0xc3</p>
<p>Cada coment√°rio de uma instru√ß√£o em assembly √© seguido pela escrita dessa instru√ß√£o usando o comando e. Se trata de um c√≥digo bem trivial, fora alguns detalhes que merecem mais aten√ß√£o.</p>
<p>Os comandos acima servem para salvar e restaurar o estado dos registradores e das flags de execu√ß√£o. Isso permite que possamos executar o c√≥digo virtualmente em qualquer posi√ß√£o que pararmos no c√≥digo depurado, j√° que retornamos tudo como estava ao final da execu√ß√£o do LoadLibrary. √â claro que isso n√£o garante que o c√≥digo estar√° 100% est√°vel em todas as condi√ß√µes, mas j√° ajuda um bocado.</p>
<p>Uma chamada atrav√©s do opcode call (c√≥digo em hexa 0xe80c) √© bem comum e se trata de uma chamada relativa, baseada no estado do Instruction Pointer atual mais o valor especificado. Por isso mesmo que fazemos o c√°lculo usando o endere√ßo de onde ser√° escrita a pr√≥xima instru√ß√£o, que √© o valor que teremos em IP quando este call for executado:</p>
<p>    ( kernel32!LoadLibraryA - @$t1 - 0x11 )</p>
<p>Quando o c√≥digo estiver completamente escrito na mem√≥ria alocada, um disassembly dele retornar√° algo parecido com o c√≥digo abaixo:</p>
<p>    push offset ntdll!DbgBreakPoint (7c901230) ; empilhamos o IP atual (endere√ßo de retorno)</p>
<p>    pushfd ; salva estado das flags atual</p>
<p>    pushad ; salva estado dos registradores atual</p>
<p>    push 8F0000h ; empilha endere√ßo do path da dll a ser carregada</p>
<p>    call kernel32!LoadLibraryA (7c801d77) ; chamamos LoadLibraryA</p>
<p>    popad ; restaura estado dos registradores</p>
<p>    popfd ; restaura estado das flags</p>
<p>    ret ; retorna para o ponto onde o depurador parou (no caso, 7c901230)</p>
<p>Voc√™ pode ver com seus pr√≥prio olhos se editar o script comentando o √∫ltimo comando (g), executando o script e executando o disassembly do IP.</p>
<p>    u @$ip</p>
<p>Somos um script bem comportado (na medida do poss√≠vel) e por isso colocamos um breakpoint tempor√°rio no final para, quando retornarmos para o c√≥digo atual, desalocarmos a mem√≥ria usada para a escrita e execu√ß√£o das instru√ß√µes.</p>
<p>    bp /1 @$t2 ".dvfree @$t0 0"</p>
<p>Eu n√£o me responsabilizo por qualquer (mau) uso do script aqui disponibilizado, assim como as eventuais perdas de c√≥digo-fonte, trilhas de HD e placas de mem√≥ria RAM pela sua execu√ß√£o. Assim sendo, bom divertimento.</p>
<p>O criador do [DriverEntry](http://www.driverentry.com.br) me questionou se n√£o seria mais f√°cil, em vez de escrever todos os opcodes em hexa, usar o comando a, que permite entrar o c√≥digo assembly diretamente a partir de um endere√ßo especificado. Essa realmente √© uma √≥tima id√©ia, e de fato eu tentei isso no come√ßo de meus testes. Por√©m, infelizmente para scripts isso n√£o funciona bem. A partir do comando a o prompt fica esperando uma entrada do usu√°rio, n√£o lendo o assembly que estaria no pr√≥prio script. Pior ainda, a escrita do assembly n√£o permite usar os registradores tempor√°rios, como $t0 ou $t1, o que nos for√ßa a escrever um c√≥digo dependende de valores constantes. Por esses motivos, tive que apelar para o comando e, que √© a forma mais confusa de escrever e entender assembly. Nesse tipo de edi√ß√£o √© vital comentar bem cada linha que se escreve.</p>
<p>[artigo anterior]: {{< relref "carregando-dlls-arbitrarias-pelo-windbg" >}}</p>
<p>[script que carrega DLLs]: loadlibrary.txt</p>
<p>[um artigo do Roberto Farah]: https://docs.microsoft.com/en-us/archive/blogs/debuggingtoolbox/windbg-script-get-portable-executable-headers</p>

</div>
  <div class="taglist">
  <p class="author">Wanderley Caloni,
     <a href="https://github.com/Caloni/blog/blob/master/content/posts/todo-dunno-original-post-source">
     2012-02-15 00:00:00 &#43;0000
     </a>
  </p>
  <a href="/categories/writting">writting</a> 
  <a href="/tags/movies">movies</a> 
  <a class="externalgray" href="https://t.me/paneloni">discuss</a>
  <script type="text/javascript" src="//cdn.livetrafficfeed.com/static/hitcounterjs/live.js?sty=49&min=1&sta=0&uni=1&tz=America%2FSao_Paulo&ro=0"></script><noscript id="LTF_hitcounter"><a href="https://livetrafficfeed.com/hit-counter">Hit Counter</a></noscript>
  </div>
  </div>
  </body>
  </html>
