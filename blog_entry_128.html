<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - 2 Coelhos</title>
  <meta name="author" content="" />
  <meta name="generator" content="Hugo 0.110.0">
  <meta property="og:title" content="2 Coelhos"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/todo-put-original-title-slug/"/>
  <meta property="og:image"
        content="/img/author.jpg"/>
  <meta property="og:description"
        content="Uma montagem impec·vel consegue dar o tom da narrativa do complexo 2 Coelhos. AlÈm de complexo, existem pequenos detalhes da trama que forÁam um pouco a realidade (como a uni„o entre o protagonista e..."/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>
  <link rel="stylesheet" type="text/css" href="/css/jquery-ui.css"/>
  <link rel="stylesheet" type="text/css" href="/css/board-min.css"/>
  <script src="/js/jquery-1.10.2.js"></script>
  <script src="/js/jquery-ui.js"></script>
  <script src="/js/pgnyui.js"></script>
  <script src="/js/pgnviewer.js"></script>
  <script src="/js/list.js"></script>
  <link rel="icon" href="/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
  <nav class="navbar has-shadow is-white"
        role="navigation" aria-label="main navigation">
  <div class="container">
  <div class="navbar-brand">
  <pre><span style="font-size: 3px; margin: 0; display: block;">
&amp;*/. .*%@@@@@@@@@@@@&amp;/    , &amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@#,*@@@@%,*&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@./@.(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@**#./((,*, *./((*,#,&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@.#@@%&amp;@@* (@@%&amp;@@/#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@,#@@&amp;&amp;@@, (@@&amp;&amp;@@*#@@@@@@@@@@@@@#/,,.         ..,/#&amp;@@@@@@@@@@@@@@@@@@@@@@@
@@@@@&amp;, .//      .//  .%@@@@@@&amp;#.  .,****.,*************,.  .(&amp;@@@@@@@@@@@@@@@@@
@@@*                     ,@/  .**,,,*********,   ,***,   ****    *@@@@@@@@@@@@@@
@#                         ,***      .******       ,***,*****,      *&amp;@@@@@@@@@@
&amp;                           ,**      .******.     .******************  (@@@@@@@@
                             ****..,*************************,    ,***   (@@@@@@
@@@@#,,,,,,,,,,,,,,,,,,,,*********,   ,**************,  .***,      .**. .  %@@@@
@@@@%                   .***,.,****,.,***,     ,****      ***.     ,******, /@@@
@@@@@&amp;.                ,**       *******,       *****,  .******************, *@@
@@@@@@@&amp;,            ,****      .********,.   .*************,  ,*****,    ,** /@
@@@@@@@@@@@@&amp;/ .****,    ************.   ****************************      **. #
@@@@@@@@@@@@@, *****,    ,***********    .******,   ,****.   .*****,***,,***** ,
@@@@@@@@@@@@&amp;..**************,  ,***********************       ,*,    ********..
@@@@@@@@@@@@&amp; ,**.    ,******.  .*******.    .**********,     .**********. .**, 
@@@@@@@@@@@@% ,*       ,***************.      .*****************************,   
@@@@@@@@@@@@@&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@,(&amp;&amp;&amp;&amp;@,(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;#*@&amp;&amp;&amp;@*#&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;
@@@@@@@@@@@@@@@@@@@@@@@@@@@@(.#@@@@(.#@@@@@@@@@@@@@@@@@@@@@#**@@@@(.#@@@@@@@@@@@
  </span></pre>
  &nbsp;
  <a class="navbar-item" title="Go to Home" href="/">
    <div class="is-6">Blogue do Caloni</div>
  </a>
  </div>
  </div>
  </nav>
  <div class="container">
  <p class="title">
  <a class="external" href="https://www.caloni.com.br/todo-put-external-link-here">
  Todo Put Post Title Here
  </a>
  </p>
  <div class="content">
<p>Em um ambiente multithreading diversas threads disputam "a tapas" a aten√ß√£o do processador (CPU). Certo? Podemos dizer que, em um ambiente com muito processamento a realizar, de certa forma √© isso que acontece. S√£o threads e mais threads rodando um pedacinho de c√≥digo cada vez que passam pelo processador.</p>
<p>Um ambiente complexo como um sistema operacional executando dezenas (√†s vezes centenas) de programas √© repleto de pequenos detalhes que podem fazer o iniciante logo desanimar quando tentar depurar um programa com mais de uma thread. De fato, eu j√° percebi que muitos n√£o v√£o saber nem como come√ßar a pensar sobre o problema.</p>
<p>Uma forma de visualizar o cen√°rio multithread come√ßa na fila das threads. Elas est√£o indo em dire√ß√£o ao guich√™ das CPUs onde v√£o conseguir tempo de processamento para rodar seu c√≥digo. Depois que elas esgotam seu tempo elas se dirigem para o final da fila esperando por mais tempo para executar mais c√≥digo.</p>
<p>Para simplificar este cen√°rio vamos imaginar duas threads iniciando com o mesmo c√≥digo. Esse c√≥digo incrementa um contador global at√© ele chegar a dez, quando a fun√ß√£o retorna e as threads terminam.</p>
<p>    int count = 0;</p>
<p>    increment() {</p>
<p>      while( count < 10 ) {</p>
<p>        count++;</p>
<p>        print(tid, count);</p>
<p>      }</p>
<p>    }</p>
<p>    main() {</p>
<p>      thread t1(increment);</p>
<p>      thread t2(increment);</p>
<p>    }</p>
<p>O tid no pseudo-c√≥digo acima √© sin√¥nimo para Thread ID, o identificador √∫nico de uma thread, que costuma ser um n√∫mero. Para simplificar vamos dar ao id os apelidos de t1 e t2. Esta √© uma poss√≠vel sa√≠da do c√≥digo acima, dependendo de quantos processadores e cores possui a m√°quina:</p>
<p>    t1 1</p>
<p>    t1 2</p>
<p>    t1 3</p>
<p>    t1 4</p>
<p>    t1 5</p>
<p>    t1 6</p>
<p>    t1 7</p>
<p>    t1 8</p>
<p>    t1 9</p>
<p>    t1 10</p>
<p>Pelo jeito a primeira thread n√£o deu chance para a outra executar. Isso acontece por causa do pequeno espa√ßo de tempo que √© necess√°rio para realizar a tarefa de incrementar uma vari√°vel. √â t√£o pequena a tarefa que nem foi suficiente para a primeira thread ficar sem tempo e a CPU mandar ela para o fim da fila. Por isso a segunda thread nunca chegou a incrementar o contador.</p>
<p>Quando uma thread quer realizar algum processamento, ela precisa entrar na fila das threads ativas, que aguardam pela CPU que ir√° atend√™-las. Nessa fila ela pega uma senha e aguarda a sua vez. S√≥ que cada vez que uma thread √© atendida ela ganha um tempo limitado de atendimento, que na arquitetura do sistema operacional √© chamado de quantum ou time slice. Se o quantum de uma thread estoura, ou a thread n√£o tem mais nada pra fazer, ela sai do guich√™ de atendimento e volta a ficar inativa, ou volta para o final da fila, aguardando por mais processamento.</p>
<p>Uma thread pode opcionalmente ir para o final da fila por conta pr√≥pria. Para isso, basta que ela chame uma fun√ß√£o do sistema operacional pedindo para dormir. Por isso geralmente essa fun√ß√£o √© chamada de sleep na API do sistema operacional. Nessa fun√ß√£o costuma haver um par√¢metro de quanto tempo a thread deseja dormir. Se for maior que zero ela vai para a fila de threads dormindo at√© passar esse tempo, para depois se dirigir √† fila de threads ativas, aguardar para ser processada. Se o tempo passado for exatamente zero ela vai direto para essa √∫ltima fila, mas ficar√° sem executar do mesmo jeito, pois esta √© a fila de quem est√° aguardando pela sua pr√≥xima fatia de tempo de processamento.</p>
<p>Se chamarmos a fun√ß√£o para dormir no c√≥digo da thread antes de voltar a incrementar o contador √© poss√≠vel que a segunda thread tenha chance de executar.</p>
<p>    increment() {</p>
<p>      while( count < 10 ) {</p>
<p>        count++;</p>
<p>        print(tid, count);</p>
<p>        sleep();</p>
<p>      }</p>
<p>    }</p>
<p>Agora cada thread, depois de incrementar uma vez o contador, volta para o final da fila. Dessa forma vemos uma thread de cada vez incrementando o mesmo contador.</p>
<p>    t1 1</p>
<p>    t2 2</p>
<p>    t1 2</p>
<p>    t2 3</p>
<p>    t1 4</p>
<p>    t2 4</p>
<p>    t2 6</p>
<p>    t2 7</p>
<p>    t1 5</p>
<p>    t1 8</p>
<p>    t2 8</p>
<p>    t2 9</p>
<p>    t2 10</p>
<p>Pera√≠, o mesmo contador? Isso pode gerar problemas. Se duas threads tentarem incrementar o mesmo contador ao mesmo tempo, quem garante que elas n√£o ir√£o incrementar o mesmo valor? Bom, se voc√™ √© bom observador j√° deve ter reparado que na execu√ß√£o acima ocorreu exatamente isso, com mais de uma thread incrementando o contador com o mesmo valor.</p>
<p>Para for√ßar isso acontecer mais r√°pido e de maneira mais gritante podemos fazer a thread ir para o final da fila antes de incrementarmos e ap√≥s pegarmos o valor atual do contador. Note que nesses testes a sa√≠da muda completamente dependendo de quantos processadores sua m√°quina tem. O resultado √†s vezes pode ser bem bizarro do que o visto nesse artigo. [^1]</p>
<p>    increment() {</p>
<p>      while( count < 10 ) {</p>
<p>        int c = count;</p>
<p>        sleep();</p>
<p>        c++;</p>
<p>        print(tid, c);</p>
<p>        count = c;</p>
<p>      }</p>
<p>    }</p>
<p>O c√≥digo acima pode gerar a seguinte sa√≠da:</p>
<p>    t1 1</p>
<p>    t2 1</p>
<p>    t1 2</p>
<p>    t2 2</p>
<p>    t1 3</p>
<p>    t2 3</p>
<p>    t1 4</p>
<p>    t2 4</p>
<p>    t1 5</p>
<p>    t2 5</p>
<p>    t2 6</p>
<p>    t1 6</p>
<p>    t2 7</p>
<p>    t1 7</p>
<p>    t1 8</p>
<p>    t2 8</p>
<p>    t2 9</p>
<p>    t1 9</p>
<p>    t2 10</p>
<p>    t1 10</p>
<p>Explicando mais uma vez com mais detalhes: quando uma thread guarda o valor do contador na vari√°vel local e volta para o final da fila, ela deixa de armazenar o contador atualizado para apenas **depois** que todas as outras threads passarem na sua frente. S√≥ que as outras threads tamb√©m pegam o mesmo valor do contador, pois ele ainda n√£o foi alterado. Quando chega a hora da segunda passada no guich√™ das CPUs, todas as threads incrementaram o mesmo valor do contador. Se houvesse apenas um processador em uma m√°quina o fluxo de execu√ß√£o do ponto de vista do processamento √∫nico para duas threads ficaria mais ou menos o seguinte (zzz √© quando uma thread dorme):</p>
<p>    t1 c = count (0)</p>
<p>    t1 zzz</p>
<p>    t2 c = count (0)</p>
<p>    t2 zzz</p>
<p>    t1 c++ (1)</p>
<p>    t2 c++ (1)</p>
<p>    t1 print c (1)</p>
<p>    t2 print c (1)</p>
<p>    t1 count = c (1)</p>
<p>    t2 count = c (1)</p>
<p>    t1 c = count (1)</p>
<p>    t1 zzz</p>
<p>    t2 c = count (1)</p>
<p>    t2 zzz</p>
<p>    ...</p>
<p>O exemplo acima for√ßou essa situa√ß√£o, mas √© preciso lembrar que isso pode acontecer mesmo sem a thread dormir. √â poss√≠vel que o tempo da thread se esgote e ela pare de ser atendida¬†justo na hora que iria salvar a vari√°vel c no contador global. Dessa forma, ela vai para o final da fila √† for√ßa e, quando voltar a ser atendida, uma outra thread j√° ter√° lido o valor anterior para ela pr√≥pria incrementar.</p>
<p>O que gostar√≠amos que acontecesse para corrigir o problema √© for√ßar a segunda thread a esperar antes que a primeira termine todo o processo de incrementar e salvar no contador global, o que resolveria o nosso problema (o wait no exemplo abaixo √© uma thread aguardando e n√£o fazendo nada):</p>
<p>    t1 c = count (0)</p>
<p>    t1 zzz</p>
<p>    t2 wait</p>
<p>    t1 c++ (1)</p>
<p>    t2 wait</p>
<p>    t1 print c (1)</p>
<p>    t2 wait</p>
<p>    t1 count = c (1)</p>
<p>    t2 wait</p>
<p>    t1 ready</p>
<p>    t2 c = count (1)</p>
<p>    t1 wait</p>
<p>    t2 c++ (2)</p>
<p>    t1 wait</p>
<p>    t2 print c (2)</p>
<p>    t1 wait</p>
<p>    t2 count = c (2)</p>
<p>    t2 ready</p>
<p>    t1 c = count (2)</p>
<p>    t2 wait</p>
<p>    ...</p>
<p>Esse wait do fluxo, ou seja, deixar a pr√≥xima thread aguardando a que chegou primeiro incrementar, pode ser obtido se utilizarmos um mecanismo de acesso exclusivo fornecido pelo sistema operacional. Uma outra hist√≥ria para contar, que chamarei de "A sala da fila das threads".</p>
<p>[^1]: Eu mesmo em meus testes n√£o pude usar sleep passando zero como o tempo para dormir porque meu n√∫mero de processadores n√£o permite que eu fa√ßa esse experimento, j√° que sempre v√£o existir processadores dispostos a reprocessar a thread que acabou de ir para o final de sua fila.</p>

</div>
  <div class="taglist">
  <p class="author">Wanderley Caloni,
     <a href="https://github.com/Caloni/blog/blob/master/content/posts/todo-dunno-original-post-source">
     2012-02-15 00:00:00 &#43;0000
     </a>
  </p>
  <a href="/categories/writting">writting</a> 
  <a href="/tags/movies">movies</a> 
  <a class="externalgray" href="https://t.me/paneloni">discuss</a>
  <script type="text/javascript" src="//cdn.livetrafficfeed.com/static/hitcounterjs/live.js?sty=49&min=1&sta=0&uni=1&tz=America%2FSao_Paulo&ro=0"></script><noscript id="LTF_hitcounter"><a href="https://livetrafficfeed.com/hit-counter">Hit Counter</a></noscript>
  </div>
  </div>
  </body>
  </html>
